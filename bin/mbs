#!/usr/bin/env python

__author__ = 'abdul'

import sys
import traceback
import os
import signal
import mbs.version
from functools import partial
from mbs.globals import State

from dargparse import dargparse
from mbs.mbs import get_mbs
from mbs.engine import STATUS_STOPPED, STATUS_STOPPING, STATUS_RUNNING, TaskWorker, TaskCleanWorker
from mbs.backup_system import BACKUP_SYSTEM_STATUS_STOPPED
from mbs.utils import (
    wait_for, document_pretty_string, resolve_path, SignalWatcher,
    prompt_confirm, call_command
    )
from mbs import mbs_config
from mbs.mbs_logging import setup_logging, redirect_std_to_logger

from mbs.persistence import get_backup, get_backup_plan, get_restore

import code

###############################################################################
# MAIN
###############################################################################
def main(args):
    register_debug_handler()

    parser = dargparse.build_parser(PARSER_DEF)

    if len(args) < 1:
        parser.print_help()
        return

    # Parse the arguments and call the function of the selected cmd
    parsed_args = parser.parse_args(args)
    command_function = parsed_args.func
    mbs_config.MBS_CONF_PATH = resolve_path(parsed_args.config_path)
    mbs_config.MBS_LOG_PATH = resolve_path(parsed_args.log_path)

    if command_function in [start_engine, start_backup_system, start_api_server]:
        log_to_stdout = getattr(parsed_args, "foreground", True)
    else:
        log_to_stdout = True

    setup_logging(log_to_stdout=log_to_stdout,
                  log_file_name=_get_log_file_name(parsed_args))

    # get the function to call from the parser framework


    return command_function(parsed_args)

###############################################################################
# Engine Commands
###############################################################################
def start_engine(parsed_args):
    engine_id = parsed_args.engineId
    engine = _get_engine(engine_id)

    handlers = {signal.SIGINT:  partial(engine.force_stop),
                signal.SIGTERM: partial(engine.force_stop)}
    with SignalWatcher(handlers) as watcher:
        status = engine.client.get_status()
        if status["status"] == STATUS_RUNNING:
            print "Engine already started"
            return
        elif status["status"] == STATUS_STOPPING:
            print ("Engine is stopping now. Please wait until it is "
                   "completely stopped then try starting again")
            return

        _do_start_engine(engine, fork=not parsed_args.foreground)

        wait_for(partial(_engine_started, engine), timeout=5)

        if _engine_started(engine):
            print "Engine started successfully!"
        else:
            print "Engine did not start. Please check logs"
            return

        wait_for(lambda: watcher.signaled or not engine.is_alive(),
                 log_func=lambda: True)


###############################################################################
def _do_start_engine(engine, fork=False):
    if fork:
        child_pid = os.fork()
        if child_pid:
            # parent process. return
            print "Forked engine process %s" % child_pid
            return
        else:
            # need to disown yourself, Son
            os.setsid()
            os.umask(0)
            # redirect std out/err to logger
            redirect_std_to_logger()


    # forked child process
    engine.start()

###############################################################################
def _engine_started(engine):
    return engine.client.get_status()["status"] == STATUS_RUNNING

###############################################################################
def stop_engine(parsed_args):
    engine_id = parsed_args.engineId
    engine = _get_engine(engine_id)
    status = engine.client.get_status()
    force = parsed_args.force
    if status["status"] == STATUS_STOPPING and not force:
        print "A stop request has already been made"
        return
    elif status["status"] == STATUS_STOPPED:
        print "Engine is not running"
        return

    _do_stop_engine(engine, force)

###############################################################################
def _engine_stopped(engine):
    return engine.client.get_status()["status"] == STATUS_STOPPED

###############################################################################
def _do_stop_engine(engine, force=False):
    print "Stopping engine gracefully"
    engine.client.stop_command()
    print "Waiting for engine to stop"
    wait_for(partial(_engine_stopped, engine), timeout=30)
    print "Done waiting for engine to stop"

    if _engine_stopped(engine):
        exit(0)

    print "Unable to gracefully stop engine within 30 seconds"

    if force:
        print "Stopping engine with force!"
        engine.force_stop()
        print "Waiting for engine to stop"
        wait_for(partial(_engine_stopped, engine), timeout=30)

        if _engine_stopped(engine):
            exit(0)
        else:
            print "Unable to stop engine within 30 seconds"

    exit(1)

###############################################################################
def restart_engine(parsed_args):
    engine_id = parsed_args.engineId
    engine = _get_engine(engine_id)

    # stop the engine and wait for it is completely stopped
    engine.client.stop_command()

    wait_for(partial(_engine_stopped, engine), timeout=100)

    if _engine_stopped(engine):
        start_engine(parsed_args)
    else:
        print "Engine did not stop yet. Please try later"
        exit(1)

###############################################################################
def status_engine(parsed_args):
    engine_id = parsed_args.engineId
    engine = _get_engine(engine_id)
    print document_pretty_string(engine.client.get_status())

###############################################################################
# Backup System Commands
###############################################################################
def start_backup_system(parsed_args):
    backup_system = _get_backup_system()

    handlers = {signal.SIGINT:  partial(backup_system.stop_backup_system),
                signal.SIGTERM: partial(backup_system.force_stop)}
    with SignalWatcher(handlers) as watcher:
        status = backup_system.get_status()
        if status["status"] == STATUS_RUNNING:
            print "Backup System already started"
            return
        elif status["status"] == STATUS_STOPPING:
            print ("Backup System is stopping now. Please wait until it is "
                   "completely stopped then try starting again")
            return

        _do_start_backup_system(fork=not parsed_args.foreground)

        def backup_system_started():
            return backup_system.get_status()["status"] == STATUS_RUNNING
        wait_for(backup_system_started, timeout=5)

        if backup_system_started():
            print "Backup System started successfully!"
        else:
            print "Backup System did not start. Please check logs"

        wait_for(lambda: watcher.signaled or not backup_system.is_alive(),
                 log_func=lambda: True)

###############################################################################
def _do_start_backup_system(fork=False):
    if fork:
        child_pid = os.fork()
        if child_pid:
            # parent process. return
            print "Forked backup system process %s" % child_pid
            return
        else:
            # need to disown yourself, Son
            os.setsid()
            os.umask(0)
            # redirect std out/err to logger
            redirect_std_to_logger()

    backup_system = _get_backup_system()
    # forked child process
    backup_system.start()

###############################################################################
def stop_backup_system(parsed_args):
    force = parsed_args.force
    if force:
        raise Exception("force option curretnly not supported")
    backup_system = _get_backup_system()

    status = backup_system.get_status()
    if status["status"] == STATUS_STOPPING:
        print "A stop request has already been made"
        return
    elif status["status"] == STATUS_STOPPED:
        print "Backup System is not running"
        return

    print "Stopping backup system..."
    if force:
        backup_system.force_stop()
    else:
        backup_system.stop_backup_system()

    def stopped():
        return backup_system.get_status()["status"] == BACKUP_SYSTEM_STATUS_STOPPED
    print "Waiting for backup system to stop"
    wait_for(stopped, timeout=100)
    print "Done waiting for backup system to stop"
    if stopped():
        print "Backup system stopped successfully. Bye!"
    else:
        print "Unable to stop backup system within 100 seconds"
        exit(1)



###############################################################################
def restart_backup_system(parsed_args):
    backup_system = _get_backup_system()

    # stop the backup_system and wait for it is completely stopped
    stop_backup_system(parsed_args)
    def backup_system_stopped():
        return backup_system.get_status()["status"] == STATUS_STOPPED

    wait_for(backup_system_stopped, timeout=100)

    if backup_system_stopped():
        start_backup_system(parsed_args)
    else:
        print "Backup System did not stop yet. Please try later"
        exit(1)

###############################################################################
def status_backup_system(parsed_args):
    print document_pretty_string(_get_backup_system().get_status())

###############################################################################
# Api Server Commands
###############################################################################
def start_api_server(parsed_args):
    client = api_client()

    handlers = {
        signal.SIGINT:  partial(client.stop_command),
        signal.SIGTERM: partial(client.stop_command)
    }
    with SignalWatcher(handlers) as watcher:
        status = client.get_status()
        if status["status"] == STATUS_RUNNING:
            print "Backup System already started"
            return
        elif status["status"] == STATUS_STOPPING:
            print ("Backup System is stopping now. Please wait until it is "
                   "completely stopped then try starting again")
            return

        _do_start_api_server(fork=not parsed_args.foreground)

        def api_server_started():
            return client.get_status()["status"] == STATUS_RUNNING
        wait_for(api_server_started, timeout=5)

        if api_server_started():
            print "Api Server started successfully!"
        else:
            print "Api Server did not start. Please check logs"

        wait_for(lambda: watcher.signaled, log_func=lambda: True)

###############################################################################
def _do_start_api_server(fork=False):
    if fork:
        child_pid = os.fork()
        if child_pid:
            # parent process. return
            print "Forked api server process %s" % child_pid
            return
        else:
            # need to disown yourself, Son
            os.setsid()
            os.umask(0)
            # redirect std out/err to logger
            redirect_std_to_logger()

    api_server = get_mbs().api_server
    # forked child process
    api_server.start()

###############################################################################
def stop_api_server(parsed_args):
    client = api_client()

    status = client.get_status()
    if status["status"] == STATUS_STOPPING:
        print "A stop request has already been made"
        return
    elif status["status"] == STATUS_STOPPED:
        print "Api Server is not running"
        return

    print "Stopping api server..."

    client.stop_command()

    def stopped():
        return client.get_status()["status"] == "stopped"
    print "Waiting for api server to stop"
    wait_for(stopped, timeout=100)

    if stopped():
        print "Api Server stopped successfully. Bye!"
    else:
        print "Unable to stop api server within 100 seconds"
        exit(1)



###############################################################################
def status_api_server(parsed_args):

    print document_pretty_string(api_client().get_status())


###############################################################################
# Backup Event Listener Commands
###############################################################################
def start_backup_event_listener(parsed_args):
    validate_event_listener()

    client = event_listener_client()

    handlers = {
        signal.SIGINT:  partial(client.stop_command),
        signal.SIGTERM: partial(client.stop_command)
    }
    with SignalWatcher(handlers) as watcher:
        status = client.get_status()
        if status["status"] == STATUS_RUNNING:
            print "BackupEventListener already started"
            return
        elif status["status"] == STATUS_STOPPING:
            print ("BackupEventListener is stopping now. Please wait until it is "
                   "completely stopped then try starting again")
            return

        _do_start_backup_event_listener(fork=not parsed_args.foreground)

        def event_listener_started():
            return client.get_status()["status"] == STATUS_RUNNING
        wait_for(event_listener_started, timeout=5)

        if event_listener_started():
            print "BackupEventListener started successfully!"
        else:
            print "BackupEventListener did not start. Please check logs"

        wait_for(lambda: watcher.signaled, log_func=lambda: True)

###############################################################################
def _do_start_backup_event_listener(fork=False):
    if fork:
        child_pid = os.fork()
        if child_pid:
            # parent process. return
            print "Forked BackupEventListener process %s" % child_pid
            return
        else:
            # need to disown yourself, Son
            os.setsid()
            os.umask(0)
            # redirect std out/err to logger
            redirect_std_to_logger()

    # forked child process
    get_mbs().backup_event_listener.start()

###############################################################################
def stop_backup_event_listener(parsed_args):
    validate_event_listener()

    client = event_listener_client()

    status = client.get_status()
    if status["status"] == STATUS_STOPPING:
        print "A stop request has already been made"
        return
    elif status["status"] == STATUS_STOPPED:
        print "BackupEventListener is not running"
        return

    print "Stopping BackupEventListener..."

    client.stop_command()

    def stopped():
        return client.get_status()["status"] == "stopped"
    print "Waiting for BackupEventListener to stop"
    wait_for(stopped, timeout=100)

    if stopped():
        print "BackupEventListener stopped successfully. Bye!"
    else:
        print "Unable to stop api server within 100 seconds"
        exit(1)

###############################################################################
def status_backup_event_listener(parsed_args):
    validate_event_listener()

    print document_pretty_string(event_listener_client().get_status())

###############################################################################
def validate_event_listener():
    if not get_mbs().backup_event_listener:
        print "No backup event listener configured"
        exit(1)

###############################################################################
def run_plan_generators(parsed_args):
    bs = _get_backup_system()
    for pg in bs.plan_generators:
        pg.run_generator(dry_run=parsed_args.dryRun)


###############################################################################
# Other Commands
###############################################################################
def generate_audit_reports(parsed_args):
    global_auditor = _get_backup_system().global_auditor
    global_auditor.generate_yesterday_audit_reports()

###############################################################################
def download_backup(parsed_args):
    backup = _get_backup(parsed_args.backupId)
    target_ref = backup.target_reference
    sec_tgt, tgt_ref = backup.get_any_active_secondary_target()

    if target_ref:
        if not backup.deleted:
            backup.target.get_file(backup.target_reference, os.getcwd())
        elif sec_tgt:
            msg = ("Backup '%s' target has been deleted but there is a "
                   "secondary target available in %s. Do want to download "
                   "from this target?" % (backup.id, sec_tgt))
            if prompt_confirm(msg):
                sec_tgt.get_file(tgt_ref, os.getcwd())
        else:
            print ("Failed to download. Backup '%s' has been deleted." %
                   backup.id)
            exit(1)
    else:
        print ("Failed to download. Backup '%s' never uploaded."
               % backup.id)
        exit(1)

###############################################################################
def download_backup_log(parsed_args):
    backup = _get_backup(parsed_args.backupId)
    if backup.log_target_reference:
        if not backup.deleted:
            backup.target.get_file(backup.log_target_reference, os.getcwd())
        else:
            print ("Failed to download. Backup '%s' is expired." %
                   backup.id)
            exit(1)

    else:
        print ("Failed to download. Log for '%s' never uploaded."
               % backup.id)
        exit(1)

###############################################################################
def delete_backup(parsed_args):
    client = api_client()
    client.delete_backup(parsed_args.backupId)

###############################################################################
def reschedule_backup(parsed_args):
    force = parsed_args.force
    backup = _get_backup(parsed_args.backupId)
    _get_backup_system().reschedule_backup(backup, force=force,
                                           reset_try_count=True)

###############################################################################
def show_backup(parsed_args):

    backup = get_backup(parsed_args.backupId)
    if backup:
        print str(backup)
    else:
        print "No such backup '%s' " % parsed_args.backupId

###############################################################################
def reschedule_all_backups(parsed_args):
    force = parsed_args.force
    get_mbs().backup_system.reschedule_all_failed_backups(force=force,
                                                          reset_try_count=True)

###############################################################################
def schedule_plan_backup(parsed_args):
    backup_system = _get_backup_system()
    plan = _get_plan(parsed_args.planId)
    backup_system.schedule_plan_backup(plan, one_time=True)

###############################################################################
def restore_backup(parsed_args):
    client = api_client()
    destination_uri = parsed_args.destinationUri
    backup_id = parsed_args.backupId
    src_db = parsed_args.sourceDatabase
    no_index_restore = parsed_args.noIndexRestore
    no_users_restore = parsed_args.noDbUsersAndRoles
    no_roles_restore = parsed_args.noDbUsersAndRoles
    result = client.restore_backup(backup_id, destination_uri, no_index_restore=no_index_restore,
                                   no_users_restore=no_users_restore, no_roles_restore=no_roles_restore,
                                   source_database_name=src_db)

    print document_pretty_string(result)

###############################################################################
def download_restore_log(parsed_args):
    restore = _get_restore(parsed_args.restoreId)
    if restore.log_target_reference:
        if not restore.log_target_reference.deleted_date:
            restore.source_backup.target.get_file(restore.log_target_reference,
                                                  os.getcwd())
        else:
            print ("Failed to download. Log for '%s' is deleted." %
                   restore.id)
            exit(1)

    else:
        print ("Failed to download. Log for '%s' never uploaded."
               % restore.id)
        exit(1)

###############################################################################
def run_backup(parsed_args):
    backup = _get_backup(parsed_args.backupId)
    TaskWorker(backup).run()

###############################################################################
def tail_backup_log(parsed_args):
    backup = _get_backup(parsed_args.backupId)
    log_path = TaskWorker(backup).get_log_path()
    tail_log(log_path)

###############################################################################
def tail_log(log_path):
    if not os.path.exists(log_path):
        raise Exception("log file not found: %s" % log_path)

    tail_cmd = ["tail", "-f", "-n", "50", log_path]
    return call_command(tail_cmd)


###############################################################################
def clean_backup(parsed_args):
    backup = _get_backup(parsed_args.backupId)
    TaskCleanWorker(backup).run()

###############################################################################
def run_restore(parsed_args):
    restore = _get_restore(parsed_args.restoreId)
    TaskWorker(restore).run()

###############################################################################
def clean_restore(parsed_args):
    restore = _get_restore(parsed_args.restoreId)
    TaskCleanWorker(restore).run()

###############################################################################
def cancel_backup(parsed_args):
    backup = _get_backup(parsed_args.backupId)
    engine = _get_engine()
    if backup.state == State.CANCELED:
        print "Backup is already canceled"
        return
    if parsed_args.force or prompt_confirm("Cancel backup '%s'?" % backup.id):
        result = engine.client.cancel_backup(backup.id)
        print document_pretty_string(result)

###############################################################################
def cancel_restore(parsed_args):
    restore = _get_restore(parsed_args.restoreId)
    engine = _get_engine()
    if restore.state == State.CANCELED:
        print "Restore is already canceled"
        return
    if parsed_args.force or prompt_confirm("Cancel restore '%s'?" % restore.id):
        result = engine.client.cancel_restore(restore.id)
        print document_pretty_string(result)

###############################################################################
def reschedule_restore(parsed_args):
    force = parsed_args.force
    restore = _get_restore(parsed_args.restoreId)
    _get_backup_system().reschedule_restore(restore, force=force)

###############################################################################
def encrypt(parsed_args):
    print "'%s'" % get_mbs().encryptor.encrypt_string(parsed_args.str)

###############################################################################
def decrypt(parsed_args):
    print "'%s'" % get_mbs().encryptor.decrypt_string(parsed_args.str)

###############################################################################
# Helpers
###############################################################################
def _get_engine(engine_id=None):

    if not engine_id:
        return get_mbs().get_default_engine()
    else:
        return get_mbs().get_engine(engine_id)

###############################################################################
def _get_backup_system():
    backup_system = get_mbs().backup_system
    if not backup_system:
        print "No backup system configured"
        exit(1)

    return backup_system

###############################################################################
def _get_backup(backup_id):
        backup = get_backup(backup_id)
        if backup:
            return backup
        else:
            print "No such backup '%s'" % backup_id
            exit(1)

###############################################################################
def _get_restore(restore_id):
    restore = get_restore(restore_id)
    if restore:
        return restore
    else:
        print "No such restore '%s'" % restore_id
        exit(1)

###############################################################################
def _get_plan(plan_id):
    plan = get_backup_plan(plan_id)
    if plan:
        return plan
    else:
        print "No such plan '%s'" % plan_id
        exit(1)

###############################################################################
def _get_log_file_name(parsed_args):
    if "start-engine" in parsed_args.raw_args:
        engine = _get_engine(parsed_args.engineId)
        return "engine_%s.log" % engine.id
    elif "start-master" in parsed_args.raw_args:
        return "backup_system.log"
    elif "start-api-server" in parsed_args.raw_args:
        return "api-server.log"
    elif "start-backup-event-listener" in parsed_args.raw_args:
        return "backup-event-listener.log"
    else:
        return "mbs.log"

###############################################################################
def api_client():
    return get_mbs().api_client

###############################################################################
def event_listener_client():
    return get_mbs().backup_event_listener.local_client




###############################################################################
def do_debug(sig, frame):
    """Interrupt running process, and provide a python prompt for
    interactive debugging."""
    d={'_frame':frame}         # Allow access to frame object.
    d.update(frame.f_globals)  # Unless shadowed by global
    d.update(frame.f_locals)

    i = code.InteractiveConsole(d)
    message  = "Signal received : entering python shell.\nTraceback:\n"
    message += ''.join(traceback.format_stack(frame))
    print message

###############################################################################
def register_debug_handler():
    signal.signal(signal.SIGUSR1, do_debug)  # Register handler

###############################################################################
# command parser
###############################################################################
PARSER_DEF = {
    "prog": "mbs",
    "usage": "Usage: mbs [<options>] <command> [<command-args>]",
    "description" : "contains commands for the mongodb-backup-system",
    "args": [
            {
            "name": "config_path",
            "type": "optional",
            "cmd_arg": "--config-path",
            "displayName": "CONFIG_PATH",
            "help": "path to mbs config ; defaults to %(default)s",
            "default": mbs_config.MBS_CONF_PATH
        },
            {
            "name": "log_path",
            "type": "optional",
            "cmd_arg": "--log-path",
            "displayName": "LOG_PATH",
            "help": "path to mbs logs ; defaults to %(default)s",
            "default": mbs_config.MBS_LOG_PATH
        },
        {
            "name": "version",
            "type" : "optional",
            "cmd_arg":  "--version",
            "nargs": 0,
            "help": "print version",
            "action": "version",
            "version": "mbs %s" % mbs.version.get_mbs_version()
        }
    ],
    "children":[
        #### start-engine ####
            {
            "prog": "start-engine",
            "shortDescription" : "starts a backup engine",
            "description" : "starts a backup engine",
            "function": start_engine,
            "args": [
                    {
                    "name": "engineId",
                    "type" : "positional",
                    "nargs": "?",
                    "displayName": "ENGINE_ID",
                    "help": "An engine id"
                },
                    {
                    "name": "fork",
                    "type" : "optional",
                    "cmd_arg":  "--fork",
                    "nargs": 0,
                    "help": "fork the engine process",
                    "action": "store_true",
                    "default": True
                },
                {
                    "name": "foreground",
                    "type" : "optional",
                    "cmd_arg":  "--foreground",
                    "nargs": 0,
                    "help": "start system in foreground",
                    "action": "store_true",
                    "default": False
                }
            ]
        },

        #### stop-engine ####
            {
            "prog": "stop-engine",
            "shortDescription" : "stops a backup engine",
            "description" : "stops a backup engine",
            "function": stop_engine,
            "args": [
                    {
                    "name": "engineId",
                    "type" : "positional",
                    "nargs": "?",
                    "displayName": "ENGINE_ID",
                    "help": "An engine id"
                } ,
                    {
                    "name": "force",
                    "type" : "optional",
                    "cmd_arg":  ["--force", "-f"],
                    "nargs": 0,
                    "help": "force stop engine",
                    "action": "store_true",
                    "default": False
                }
            ]
        },
        #### status-engine ####
            {
            "prog": "status-engine",
            "shortDescription" : "gets the status of a backup engine",
            "description" : "gets the status of a backup engine",
            "function": status_engine,
            "args": [
                    {
                    "name": "engineId",
                    "type" : "positional",
                    "nargs": "?",
                    "displayName": "ENGINE_ID",
                    "help": "An engine id"
                }
            ]
        },

        #### restart-engine ####
            {
            "prog": "restart-engine",
            "shortDescription" : "restarts the backup engine",
            "description" : "restarts the backup engine",
            "function": restart_engine,
            "args": [
                    {
                    "name": "engineId",
                    "type" : "positional",
                    "nargs": "?",
                    "displayName": "ENGINE_ID",
                    "help": "An engine id"
                },
                    {
                    "name": "fork",
                    "type" : "optional",
                    "cmd_arg":  "--fork",
                    "nargs": 0,
                    "help": "fork the engine process",
                    "action": "store_true",
                    "default": False
                }
            ]
        },
            {
            "prog": "start-master",
            "shortDescription" : "starts the backup system",
            "description" : "starts the backup system",
            "function": start_backup_system,
            "args": [
                    {
                    "name": "fork",
                    "type" : "optional",
                    "cmd_arg":  "--fork",
                    "nargs": 0,
                    "help": "fork the engine process",
                    "action": "store_true",
                    "default": True
                },
                {
                    "name": "foreground",
                    "type" : "optional",
                    "cmd_arg":  "--foreground",
                    "nargs": 0,
                    "help": "start system in foreground",
                    "action": "store_true",
                    "default": False
                }
            ]
        },

        #### stop-master ####
            {
            "prog": "stop-master",
            "shortDescription" : "stops the backup system",
            "description" : "stops the backup system",
            "function": stop_backup_system,
            "args": [
                    {
                    "name": "force",
                    "type" : "optional",
                    "cmd_arg":  ["--force", "-f"],
                    "nargs": 0,
                    "help": "force stop backup_system",
                    "action": "store_true",
                    "default": False
                }
            ]
        },
        #### status-master ####
            {
            "prog": "status-master",
            "shortDescription" : "gets the status of the backup system",
            "description" : "gets the status of the backup system",
            "function": status_backup_system
        },

        #### restart-master ####
            {
            "prog": "restart-master",
            "shortDescription" : "restart backup system",
            "description" : "restart backup system",
            "function": restart_backup_system,
            "args": [
                    {
                    "name": "fork",
                    "type" : "optional",
                    "cmd_arg":  "--fork",
                    "nargs": 0,
                    "help": "fork the engine process",
                    "action": "store_true",
                    "default": False
                }
            ]
        },

            {
                "prog": "start-api-server",
                "shortDescription": "starts the api server",
                "description": "starts the api server",
                "function": start_api_server,
                "args": [
                    {
                        "name": "fork",
                        "type": "optional",
                        "cmd_arg":  "--fork",
                        "nargs": 0,
                        "help": "fork the api server process",
                        "action": "store_true",
                        "default": True
                    },
                    {
                        "name": "foreground",
                        "type": "optional",
                        "cmd_arg":  "--foreground",
                        "nargs": 0,
                        "help": "start server in foreground",
                        "action": "store_true",
                        "default": False
                    }
                ]
            },

            #### stop-api-server ####
            {
                "prog": "stop-api-server",
                "shortDescription": "stops the backup system",
                "description": "stops the backup system",
                "function": stop_api_server,
                "args": [
                    {
                        "name": "force",
                        "type" : "optional",
                        "cmd_arg":  ["--force", "-f"],
                        "nargs": 0,
                        "help": "force stop api server",
                        "action": "store_true",
                        "default": False
                    }
                ]
            },
            #### status-api-server ####
            {
                "prog": "status-api-server",
                "shortDescription": "gets the status of the api server",
                "description": "gets the status of the backup system",
                "function": status_api_server
            },


        {
            "prog": "start-backup-event-listener",
            "shortDescription": "starts the event listener server",
            "description": "starts the api server",
            "function": start_backup_event_listener,
            "args": [
                {
                    "name": "fork",
                    "type": "optional",
                    "cmd_arg":  "--fork",
                    "nargs": 0,
                    "help": "fork the server process",
                    "action": "store_true",
                    "default": True
                },
                {
                    "name": "foreground",
                    "type": "optional",
                    "cmd_arg":  "--foreground",
                    "nargs": 0,
                    "help": "start server in foreground",
                    "action": "store_true",
                    "default": False
                }
            ]
        },

        #### stop-api-server ####
        {
            "prog": "stop-backup-event-listener",
            "shortDescription": "stops the event listener",
            "description": "stops the event listener",
            "function": stop_backup_event_listener,
            "args": [
                {
                    "name": "force",
                    "type": "optional",
                    "cmd_arg":  ["--force", "-f"],
                    "nargs": 0,
                    "help": "force stop event listener",
                    "action": "store_true",
                    "default": False
                }
            ]
        },
        #### status-backup-event-listener ####
        {
            "prog": "status-backup-event-listener",
            "shortDescription": "gets the status of the event listener",
            "description": "gets the status of the event listener",
            "function": status_backup_event_listener
        },
        #### run-plan-generators ####
            {
            "prog": "run-plan-generators",
            "shortDescription": "Runs plans generators",
            "description": "Runs plans generators",
            "function": run_plan_generators,
            "args": [
                {
                    "name": "dryRun",
                    "type": "optional",
                    "cmd_arg":  ["-n", "--dry-run"],
                    "nargs": 0,
                    "help": "dry run",
                    "default": False
                }
            ]
        },
            {
            "prog": "generate-audit-reports",
            "shortDescription" : "generates audit reports as of yesterday",
            "description" : "generates audit reports as of yesterday",
            "function": generate_audit_reports
        },

            {
            "prog": "download-backup",
            "shortDescription" : "Downloads backup file from target to "
                                 "current working directory",
            "description" : "Downloads backup file from target to "
                            "current working directory",
            "args": [
                {
                "name": "backupId",
                "type" : "positional",
                "nargs": 1,
                "displayName": "BACKUP_ID",
                "help": "Backup id"
            }],
            "function": download_backup
        },

            {
            "prog": "download-backup-log",
            "shortDescription" : "Downloads log file for specified backup "
                                 "to current working directory",
            "description" : "Downloads log file for specified backup "
                            "to current working directory",
            "args": [
                    {
                    "name": "backupId",
                    "type" : "positional",
                    "nargs": 1,
                    "displayName": "BACKUP_ID",
                    "help": "Backup id"
                }],
            "function": download_backup_log
        },

            {
            "prog": "delete-backup",
            "shortDescription" : "Deletes specified backup",
            "description" : "Deletes specified backup",
            "args": [
                    {
                    "name": "backupId",
                    "type" : "positional",
                    "nargs": 1,
                    "displayName": "BACKUP_ID",
                    "help": "Backup id"
                }],
            "function": delete_backup
        },

            {
            "prog": "show-backup",
            "shortDescription" : "Shows the backup document",
            "description" : "Shows the backup document",
            "args": [
                {
                    "name": "backupId",
                    "type" : "positional",
                    "nargs": 1,
                    "displayName": "BACKUP_ID",
                    "help": "Backup id"
                }],
            "function": show_backup
        },

            {
            "prog": "restore-backup",
            "shortDescription" : "Schedules a restore for the specified"
                                 " backup into specified destination uri",

            "description" : "Schedules a restore for the specified"
                            " backup into specified destination uri",
            "args": [
                    {
                    "name": "backupId",
                    "type" : "positional",
                    "nargs": 1,
                    "displayName": "BACKUP_ID",
                    "help": "Backup id"
                },
                    {
                    "name": "destinationUri",
                    "type" : "positional",
                    "nargs": 1,
                    "displayName": "DESTINATION_URI",
                    "help": "Destination URI"
                },

                    {
                    "name": "sourceDatabase",
                    "type" : "optional",
                    "cmd_arg":  ["--source-database"],
                    "nargs": 1,
                    "help": "Name of the database to restore from (used with"
                            " server/cluster level backups to restore a single"
                            " db)"
                },

                    {
                    "name": "noIndexRestore",
                    "type" : "optional",
                    "cmd_arg":  ["--noIndexRestore"],
                    "nargs": 0,
                    "help": "Don't restore indexes",
                    "action": "store_true",
                    "default": False
                },

                    {
                    "name": "noDbUsersAndRoles",
                    "type" : "optional",
                    "cmd_arg":  ["--noDbUsersAndRoles"],
                    "nargs": 0,
                    "help": "Don't restore db user/roles",
                    "action": "store_true",
                    "default": False
                }
            ],
            "function": restore_backup
        },

            {
            "prog": "download-restore-log",
            "shortDescription" : "Downloads log file for specified restore "
                                 "to current working directory",
            "description" : "Downloads log file for specified restore "
                            "to current working directory",
            "args": [
                    {
                    "name": "restoreId",
                    "type" : "positional",
                    "nargs": 1,
                    "displayName": "RESTORE_ID",
                    "help": "Restore id"
                }],
            "function": download_restore_log
        },


        {
            "prog": "reschedule-backup",
            "shortDescription" : "Reschedules specified backup",
            "description" : "Reschedules specified backup. "
                            "Only applicable to failed backups",
            "args": [
                    {
                    "name": "backupId",
                    "type" : "positional",
                    "nargs": 1,
                    "displayName": "BACKUP_ID",
                    "help": "Backup id"
                },
                    {
                    "name": "force",
                    "type" : "optional",
                    "cmd_arg":  ["--force", "-f"],
                    "nargs": 0,
                    "help": "clears backup log",
                    "action": "store_true",
                    "default": False
                }

            ],
            "function": reschedule_backup
        },

            {
            "prog": "reschedule-all-backups",
            "shortDescription" : "Reschedules all failed backups",
            "description" : "Reschedules all failed backups",
            "args": [
                    {
                    "name": "force",
                    "type" : "optional",
                    "cmd_arg":  ["--force", "-f"],
                    "nargs": 0,
                    "help": "clears backup log",
                    "action": "store_true",
                    "default": False
                }

            ],
            "function": reschedule_all_backups,
        },

            {
            "prog": "schedule-plan-backup",
            "shortDescription" : "Schedules a one-time backup for the "
                                 "specified plan",
            "description" : "Schedules a one-time backup for the "
                            "specified plan",
            "args": [
                    {
                    "name": "planId",
                    "type" : "positional",
                    "nargs": 1,
                    "displayName": "PLAN_ID",
                    "help": "Plan id"
                }],
            "function": schedule_plan_backup
        },

        {
            "prog": "run-backup",
            "shortDescription": "Runs the backup",
            "description": "Runs the backup",
            "args": [
                {
                    "name": "backupId",
                    "type": "positional",
                    "nargs": 1,
                    "displayName": "BACKUP_ID",
                    "help": "Backup ID"
                }
            ],
            "function": run_backup
        },

        {
            "prog": "tail-backup-log",
            "shortDescription": "Tails the backup log",
            "description": "Runs the backup",
            "args": [
                {
                    "name": "backupId",
                    "type": "positional",
                    "nargs": 1,
                    "displayName": "BACKUP_ID",
                    "help": "Backup ID"
                }
            ],
            "function": tail_backup_log
        },
        {
            "prog": "clean-backup",
            "shortDescription": "Cleans the backup workspace",
            "description": "Cleans the backup workspace",
            "args": [
                {
                    "name": "backupId",
                    "type": "positional",
                    "nargs": 1,
                    "displayName": "BACKUP_ID",
                    "help": "Backup ID"
                }
            ],
            "function": clean_backup
        },

        {
            "prog": "cancel-backup",
            "shortDescription": "Cancels backup running on local engine",
            "description": "Cancels backup running on local engine",
            "args": [
                {
                    "name": "backupId",
                    "type": "positional",
                    "nargs": 1,
                    "displayName": "BACKUP_ID",
                    "help": "Backup ID"
                },
                {
                    "name": "force",
                    "type": "optional",
                    "cmd_arg":  ["--force", "-f"],
                    "nargs": 0,
                    "help": "force cancel without prompting",
                    "action": "store_true",
                    "default": False
                }
            ],
            "function": cancel_backup
        },

        {
            "prog": "cancel-restore",
            "shortDescription": "Cancels restore running on local engine",
            "description": "Cancels restore running on local engine",
            "args": [
                {
                    "name": "restoreId",
                    "type": "positional",
                    "nargs": 1,
                    "displayName": "RESTORE_ID",
                    "help": "Restore ID"
                },
                {
                    "name": "force",
                    "type": "optional",
                    "cmd_arg":  ["--force", "-f"],
                    "nargs": 0,
                    "help": "force cancel without prompting",
                    "action": "store_true",
                    "default": False
                }
            ],
            "function": cancel_restore
        },

        {
            "prog": "run-restore",
            "shortDescription": "Runs the restore",
            "description": "Runs the restore",
            "args": [
                {
                    "name": "restoreId",
                    "type": "positional",
                    "nargs": 1,
                    "displayName": "RESTORE_ID",
                    "help": "Restore ID"
                }
            ],
            "function": run_restore
        },
        {
            "prog": "clean-restore",
            "shortDescription": "Cleans the restore",
            "description": "Cleans the restore",
            "args": [
                {
                    "name": "restoreId",
                    "type": "positional",
                    "nargs": 1,
                    "displayName": "RESTORE_ID",
                    "help": "Restore ID"
                }
            ],
            "function": clean_restore
        },
        {
            "prog": "reschedule-restore",
            "shortDescription": "Reschedules specified restore",
            "description": "Reschedules specified restore. Only applicable "
                           "to failed restores",
            "args": [
                {
                    "name": "restoreId",
                    "type": "positional",
                    "nargs": 1,
                    "displayName": "RESTORE_ID",
                    "help": "Restore id"
                },
                {
                    "name": "force",
                    "type": "optional",
                    "cmd_arg":  ["--force", "-f"],
                    "nargs": 0,
                    "help": "clears restore log",
                    "action": "store_true",
                    "default": False
                }

            ],
            "function": reschedule_restore
        },


        {
            "prog": "encrypt",
            "shortDescription": "Encrypts a string using mbs configured encryptor",
            "description": "Encrypts a string using mbs configured encryptor",
            "args": [
                {
                    "name": "str",
                    "type": "positional",
                    "nargs": 1,
                    "displayName": "STR",
                    "help": "String to encrypt"
                }

            ],
            "function": encrypt
        },

        {
            "prog": "decrypt",
            "shortDescription": "Decrypts a string using mbs configured encryptor",
            "description": "Decrypts a string using mbs configured encryptor",
            "args": [
                {
                    "name": "str",
                    "type": "positional",
                    "nargs": 1,
                    "displayName": "STR",
                    "help": "String to decrypt"
                }

            ],
            "function": decrypt
        },
    ]
}

###############################################################################
########################                   ####################################
########################     BOOTSTRAP     ####################################
########################                   ####################################
###############################################################################


if __name__ == '__main__':
    try:

        main(sys.argv[1:])
    except (SystemExit, KeyboardInterrupt) , e:
        if hasattr(e, 'code') and e.code == 0:
            pass
        else:
            raise
    except:
        traceback.print_exc()
        raise
